/**
 * @module @particle/fetch-file
 * @typicalname fetchFile
 */

const fs = require('fs');
const crypto = require('crypto');
const fetch = require('node-fetch');
const progress = require('progress-stream');
const AbortController = require('abort-controller');
const { FetchError } = fetch;

/**
 * @typedef InternalState
 * @type {Object=}
 * @private
 */

/**
 * Info about the downloaded file
 * @typedef DowloadedFile
 * @type {Object=}
 * @property {string} filename - Filename of downloaded file
 * @property {string} hash - Checksum for downloaded file
 */

/**
 * Progress data passed to `onProgress` callback
 * @typedef {Object} Progress
 * @property {number} length - size in bytes of your file
 * @property {number} transferred - bytes processed
 * @property {number} remaining - bytes remaining to be processed
 * @property {number} percentage - percentage of bytes transferred (0-100)
 */

/**
 * @typedef {function(Progress)} onProgress
 * @callback onProgress
 * @param {Progress} progress - progress info for file
 */

/**
 * Tries really, really, really hard to download a file, verifying integrity of
 * the downloaded bits and optionally reporting progress along the way. Also
 * supports cancellation.
 *
 * @param {string} url - The URL for the file you'd like to download
 * @param {string} destination - Path where downloaded bits will be saved
 * @param {object=} options
 * @param {object=} options.signal - AbortSignal object as defined in
 * https://dom.spec.whatwg.org/#interface-AbortSignal (optional)
 * @param {object=} options.headers - Request headers as key-value map object (optional)
 * @param {number=} [options.maxRetries=3] - How many times to retry before
 * giving up (optional)
 * @param {onProgress=} options.onProgress - Function to call with progess info (optional)
 * @param {number=} [options.interval=100] - How often to report progress in
 * milliseconds (optional)
 * @param {string=} [options.algorithm=sha256] - Algorith to use when
 * verifying checksum - supports whatever node's crypto.createHash() method
 * does (optional)
 * @param {InternalState} state
 * @returns {Promise<DowloadedFile|Error>} A promise for the downloaded file or
 * an error
 *
 * @example
 *
 * // download a file
 * const result = await fetchFile(url, tmpFile.path);
 *
 * // download a file and report progress
 * const onProgress = (progress) => console.log(progress);
 * const result = await fetchFile(url, tmpFile.path, { onProgress, interval: 250 });
 *
 * // download a file but don't retry if the first attempt fails
 * const result = await fetchFile(url, tmpFile.path, { maxRetries: 0 });
 *
 * // cancel downloading a file
 * const { AbortController } = fetchFile;
 * const controller = new AbortController();
 *
 * try {
 *    setTimeout(() => controller.abort(), 50);
 *    await fetchFile(url, tmpFile.path, { signal });
 * } catch (error){
 *    error.type; // 'aborted'
 *    error.name; // 'AbortError'
 *    error.message; // 'The user aborted a request.'
 * }
 */
module.exports = async function fetchFile(
	url,
	destination,
	{
		signal,
		headers,
		maxRetries,
		onProgress,
		interval = 100,
		algorithm = 'sha256'
	} = {},
	state
){
	const { headers: hdrs, body } = await fetchStream(url, { signal, headers, maxRetries });

	return new Promise((resolve, reject) => {
		if (!state || state.__internal__ !== module.exports.__internal__){
			const hash = crypto.createHash(algorithm);
			const contentLength = parseInt(hdrs.get('content-length'), 10) || 0;
			const progStream = createProgressStream({ interval, contentLength, onProgress });
			const destStream = fs.createWriteStream(destination);
			state = DownloadState.create({ hash, contentLength, progStream, destStream });
			state.setupDestinationPipe(resolve, reject);
		}

		body.on('data', chunk => state.onChunk(chunk));
		body.on('error', (error) => {
			body.unpipe().destroy();
			state.onError(reject, error);
		});
		body.on('end', () => {
			if (state.isComplete()){
				state.progStream.end();
				return;
			}

			if (hdrs.get('accept-ranges') !== 'bytes'){
				const message = `unable to retreive all content from ${url}`;
				const error = new FetchError(message, 'request');
				state.onError(reject, error);
				return;
			}

			const range = { Range: `bytes=${state.piped}-${state.contentLength}` };
			const options = { signal, maxRetries, headers: clone(headers, range) };
			fetchFile(url, destination, options, state).catch(reject);
		});

		body.pipe(state.progStream, { end: false });
	});
};

module.exports.AbortController = AbortController;


// UTILS //////////////////////////////////////////////////////////////////////
const retryableStatusCodes = [408, 413, 429, 500, 502, 503, 504];
async function fetchStream(
	url,
	{
		headers,
		signal,
		timeout = 5 * 60 * 1000,
		maxRetries = 3
	} = {},
	retries = 0
){
	const res = await fetch(url, { headers, signal, timeout });
	const { ok, status } = res;

	if (!ok){
		if (retryableStatusCodes.includes(status) && retries < maxRetries){
			return fetchStream(url, { signal, headers, maxRetries }, retries += 1);
		}
		throw new FetchError(`request failed with ${status}`, 'request');
	}
	return res;
}

function createProgressStream({ interval, contentLength, onProgress = () => {} }){
	// TODO (mirande): we might want to just create our own progress stream
	// see: https://github.com/freeall/progress-stream/issues/29
	const options = { time: interval, length: contentLength };
	return progress(options, ({ length, transferred, remaining, percentage }) => {
		onProgress({ length, transferred, remaining, percentage });
	});
}

function clone(...args){
	return Object.assign({}, ...args);
}

class DownloadState {
	constructor({ contentLength, hash, progStream, destStream }){
		this.__internal__ = module.exports.__internal__;
		this.contentLength = contentLength;
		this.progStream = progStream;
		this.destStream = destStream;
		this.hash = hash;
		this.retries = 0;
		this.piped = 0;
	}

	static create(...args){
		return new DownloadState(...args);
	}

	setupDestinationPipe(resolve, reject){
		const { destStream, progStream } = this;
		destStream.on('error', error => this.onError(reject, error));
		destStream.on('finish', () => this.onComplete(resolve));
		progStream.pipe(destStream);
		return this;
	}

	onChunk(chunk){
		this.hash.update(chunk);
		this.piped += chunk.length;
	}

	onError(reject, error){
		this.progStream.unpipe().destroy();
		this.destStream.destroy();
		reject(error);
	}

	onComplete(resolve){
		const { destStream, hash } = this;
		return resolve({ filename: destStream.path, hash: hash.digest('hex') });
	}

	isComplete(){
		return this.piped >= this.contentLength;
	}
}


// TEST-ONLY EXPORTS //////////////////////////////////////////////////////////
module.exports.__internal__ = Symbol('internal');
module.exports[module.exports.__internal__] = {
	fetchStream,
	createProgressStream,
	DownloadState,
	FetchError
};

